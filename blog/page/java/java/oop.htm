객체지향 프로그래밍(OOP - Object Oriented Programming)
  - 현실세계에 존재하는 사물을 모델링하여 클래스 자료형 작성 후 객체
    (Object)를 생성한 후 객체를 이용해 프로그램을 작성하는 방법
  - 클래스 배포 가능 >> 프로그램 생산성 증가와 유지보수의 용이성 제공
  - 객체지향 프로그래밍 : 추상화, 캡슐화, 다형성, 상속성
  - 추상화(Abstraction) : 현실세계에 존재하는 사물을 속성(Field)과
    기능(Method)으로 구분하여 클래스로 만들어 주는 방법 
  
● 클래스(Class) - 참조형(Reference Type)
  - 인스턴스를 만들기 위한 자료형 >> 인스턴스(Instance) = 객체(Object)
  - 필드(Field)와 메소드(Method)의 모임
  - 클래스 선언 방법
    public class 클래스명 {
        필드(Field);//메소드에서 필요로 하는 정보를 제공할 목적의 변수
        ...

        생성자(Constructor);//인스턴스 생성을 목적으로 하는 메소드
        ...

        메소드(Method);//기능을 제공할 목적의 명령들의 모임
        ...
    }
  - 인스턴스 생성 방법
    클래스명 참조변수=new 클래스명();
  - 인스턴스 사용 방법
    >> 참조변수에 저장된 인스턴스 정보로 필드 또는 메소드 접근 - . 연산자 이용
   형식) 인스턴스정보.필드 or 인스턴스정보.메소드   
    
● 메소드(Method)
  - 필드에 저장된 정보를 제어하기 위한 명령들의 모임 >> 기능
  - 메소드 선언 방법
    자료형 메소드명(자료형 변수명, 자료형 변수명,...) {
         명령;
         ... 
    }
    >> 메소드 반환형(ReturnType - 결과형:ResultType) : 메소드를 호출하여 얻을 수 있는 결과의 자료형          
     ※ void : 무반환형 - 메소드를 호출하여 얻을 수 있는 결과가 없을 경우 사용하는 자료형 

    >> 메소드 매개변수(Parameter - 인자:Argument) : 메소드의 명령을 실행하기 위해 필요한 정보를 전달받아 저장하기 위한 변수
        
  - 메소드 호출(Method Invoke) 방법
    >> 메소드를 호출해야 메소드에 작성된 명령들이 실행되어 기능 제공
    형식) 인스턴스.메소드명(필요정보, 필요정보,...);  
     ※ 매개변수에 정보를 제대로 전달하지 않으면 메소드 호출 불가
     
  - return : 메소드를 종료하는 명령 - 제어문
    형식1) if(조건식) return;  >> 조건식의 결과가 참인 경우 메소드 종료 
    형식2) return 대상; >> 대상정보를 메소드 호출 명령으로 반환 

     ※ 대상의 자료형과 메소드 반환형의 자료형은 반드시 동일

● 메소드 오버로드(Method Overload)
  - 클래스에 동일한 이름의 메소드를 선언할 수 있는 방법
    >> 동일한 기능을 제공하는 메소드는 같은 이름의 메소드명으로 선언하는 것을 권장
  - 오버로드 작성 규칙
    >> 클래스에서 동일한 메소드명으로 선언하며 메소드 파라메터의 갯수,자료형등을 다르게 선언
    >> 메소드의 접근지정자, 반환형은 오버로드와 무관
  - 파라메터에 전달되는 값에 따라 다른 메소드 호출 : 다형성 
  - 다형성 : 동일한 이름의 메소드를 호출해도 때에 따라 다른 메소드가 호출되어 기능 제공
    >> 메소드 오버로드, 메소드 오버라이드   
  
● 생성자(Constructor)
  - 인스턴스를 생성을 목적으로 선언하는 특별한 메소드
    >> 기능 제공이 목적으로 하지 않는 메소드 - 인스턴스로 호출 불가능  
  - 생성자를 선언하지 않아도 내부적으로 기본 생성자가 있는 것으로 처리
    >> 생성자를 선언하지 않아도 기본 생성자로 인스턴스 생성 가능
   ※ 기본 생성자(Default Constructor) : 파라메터와 명령이 없는 생성자

  - 생성자를 선언하는 이유
    >> 인스턴스 생성시 초기값을 전달하여 필드에 저장하기 위해 선언
    >> 인스턴스 생성 후 필요한 초기화 작업을 위해 선언 - GUI 프로그램의 디자인 작업 

  - 생성자 인스턴스를 만들때 자동 호출 => 인위적 호출 불가능
  - 생성자 작성 방법
    >> 반환형 미선언 - 값 반환 불가능
    >> 생성자명은 반드시 클래스명과 동일하게 작성
    >> 오버로딩 작성 가능 - 파라메터에 따라 여러개의 생성자 선언 가능

    형식) public 클래스명() { //Ctrl+Space >> Constructor 선택 >> Enter
  	      //기본 생성자는 명령 미작성
          }
          
          public 클래스명(파라메터,...) { //Alt+Shift+S >> O >> 필드 선택 >> Generate
              //인스턴스가 생성될때 실행될 명령 작성 - 필드 초기화
          } 

    >> 생성자를 하나라도 선언하면 기본적으로 제공하는 기본 생성자는 소멸
       되므로 기본 생성자를 반드시 선언하는 것을 권장 - 상속 문제 때문

● this 키워드 : 메소드에서 클래스 자신의 인스턴스 정보를 저장하여 사용하기 위한 키워드
  - 메소드의 파라메터에 숨겨져 클래스의 인스턴스를 저장하는 참조변수
      >> 메소드를 호출한 인스턴스 정보를 자동으로 전달되어 저장
  
  - this 참조변수가 존재해야 되는 이유
    >> 클래스를 이용하여 인스턴스를 생성할 경우 필드는 인스턴스 마다 메모리에 따로 생성되지만 메소드는 클래스에 하나만 존재 => 메모리 절약
    >> 메소드에서 인스턴스 필드를 구분하기 위해 this 사용

  - this 키워드를 생략하여 표현하지 않아도 자동으로 인식
  - this 키워드를 이용해야 되는 경우
  
    1) 필드(this 사용)와 파라메터를 구분하기 위해 사용
      ex) public class Test {
               private int su;
               public void setSu(int su) {
                   this.su=su;
               }
          }
  
    2) 클래스의 생성자에서 다른 생성자를 호출하기 위해 사용    
      >> 생성자의 초기화 코드가 중복될 경우 코드 중복 최소화를 위해 사용
      형식) this(값,...);//생성자 호출 - 생성자에서만 작성 가능한 코드 
      >> this 키워드로 생성자 호출하는 명령은 최초 명령으로만 작성 가능

● static 키워드 : 인스턴스에 독립적인 필드 또는 메소드를 선언하기 위한 키워드
  1. static 필드 : 정적 필드
   - 모든 인스턴스가 공유하여 사용하는 필드 
   - 클래스가 메모리에 저장되면 하나만 생성되는 필드
     >> 인스턴스 생성과 무관 - 생성자 초기화 작업 불필요
      
   - static 필드 선언 방법
     접근지정자 static 자료형 필드명=초기값;
     >> 초기값이 생략될 경우 필드 기본값 저장
   
   - static 필드 접근 방법 : 클래스를 이용하여 필드 접근
     형식) 클래스명.필드 >> 필드가 private 접근지정자로 선언된 경우 접근 불가능
     
   - static 필드 사용 이유
     >> 메모리 절약과 데이타 변경 및 사용의 용이성  
      
  2. static 메소드 : 정적 메소드 
   - this 참조변수가 존재하지 않는 메소드 
     >> 인스턴스 필드 또는 인스턴스 메소드 접근 불가능
     >> static 필드 또는 static 메소드 접근 가능

   - static 메소드 선언 방법
    형식) 접근지정자 static 반환형 메소드명(매개변수,... ) {
   	       static 필드값 제어 명령;
          }

   - static 메소드 호출 방법 : 클래스를 이용하여 메소드 호출 
    형식) 클래스명.메소드명(값,...);
    
   - static 메소드 사용 이유 : 메소드 간편 호출