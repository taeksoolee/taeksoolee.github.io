● 클래스의 관계
  - 일반화 관계(Generalization) 
    >> 상속관계 : is a 관계 
    >> 부모클래스를 상속 받아 자식클래스에서 사용
    ex) 사원클래스     관리자클래스
        >> 관리자는 사원이다. (O)
        >> 사원은 관리자다.   (X)

  - 실체화 관계(Realization)
    >> 인터페이스를 상속 받아 자식클래스에서 재정의하여 사용
    ex) 도형 인터페이스 >> 원클래스  or  삼각형클래스

  - 연관 관계(Association) 또는 직접 연관 관계(Direct Association)
    >> 포함관계 : has a 관계
    >> 클래스 안에 필드를 참조변수로 선언하여 사용 - 인스턴스 정보 저장
    ex) Computer  <<  CPU + Mainboard + Memory 

  - 집합 연관 관계(Aggregation) 
    >> UML2.0에서는 연관관계로 표현 
    >> 포함 관계의 인스턴스와 생명주기 다른 경우
    ex)  컴퓨터 << 프린터

  - 복합 연관 관계(Compostion) 
    >> 포함 관계의 인스턴스와 생명주기 같은 경우
    ex)  게임  <<  캐릭터

  - 의존 관계(Dependency)
    >> 메소드의 파라메터로 선언되어 사용되는 참조변수
    >> 일시적으로 메소드에서 인스턴스를 사용할 경우
    ex)  TV   <<   리모콘

  ※ ObjectAid 설치(이클립스의 확장 프로그램) >> https://www.objectaid.com

● 상속(Inheritance) : 클래스를 물려받아 사용하는 기능  
  - 상속을 사용하는 이유
    >> 기존 클래스를 활용하여 보다 빠르게 새로운 클래스 작성 : 프로그램의 생산성 증가
     ex) 자료실 => 게시판(상속) + 파일처리
    >> 공통적인 속성과 기능을 정의한 클래스를 생성하여 상속 받아 사용 : 유지보수 효율성 증가
      ex) 사람 >> 학생,강사,직원
  - 물려주는 클래스 : 부모클래스, 선조클래스, 슈퍼클래스, 기본클래스
    물려받는 클래스 : 자식클래스, 후손클래스, 서브클래스, 파생클래스
  - 부모클래스의 생성자는 자식클래스에게 상속 불가능
  - 부모클래스의 은닉화 선언된 필드 또는 메소드는 상속 되지만 접근 불가능
  - 상속 방법 : 단일 상속 >> 부모클래스가 하나만 존재
    public class 자식클래스 extends 부모클래스 {
        //부모클래스의 필드 및 메소드 사용 가능
    }    
  - 자식클래스로 인스턴스를 생성할 경우 자식클래스의 생성자가 실행되기 전에 부모클래스 생성자가 먼저 실행  
    >> 부모 인스턴스 생성 후 자식 인스턴스 생성

● super 키워드
  - 자식클래스의 메소드에서 부모 인스턴스를 표현할 때 사용하는 키워드
    >> 자식클래스의 메소드에서 부모 인스턴스의 필드 또는 메소드에 접근하기 위해 사용
    >> 자식클래스의 필드 또는 메소드가 아닌 경우 자동으로 부모클래스의 필드 또는 메소드 사용 : super 생략 가능
  - super 키워드를 사용하는 경우
    1) 자식클래스의 생성자에서 부모클래스 생성자를 호출하기 위해 사용
     >> 자식클래스의 생성자가 호출되기 전에 super 키워드에 의해 부모클래스의 생성자가 먼저 호출
     >> super 키워드로 생성자 호출하는 명령은 생성자에서 최초의 명령으로 반드시 작성 
     >> super 키워드로 부모클래스의 생성자 호출이 생략된 경우 기본 생성자 호출
     형식) super(값,...);  
    2) 오버라이드 선언되어 숨겨진 부모클래스의 메소드에 직접 접근해야 할 경우 사용
     형식) super.메소드명(값,...); 

● 메소드 오버라이드(Method Override) : 상속관계에서만 구현 가능
  - 부모클래스의 메소드를 자식클래스에서 재선언 하는 기능
  - 자식클래스에서 메소드를 오버라이드 선언한 경우 부모클래스의 메소드는 
    숨겨지고 자식클래스의 메소드만 사용
  - 부모클래스의 메소드의 머릿부를 동일하게 선언
    >> 접근지정자, 반환형, 메소드명, 파라메터, 예외전달이 반드시 동일
      
● 상속 관계에서 참조변수(레퍼런스변수)와 인스턴스의 사용법
  1. 부모클래스 참조변수=new 부모클래스();//가능
     >> 참조변수는 부모클래스 요소에 접근 가능
  2. 자식클래스 참조변수=new 자식클래스();//가능
     >> 참조변수는 자식클래스의 요소 및 부모클래스의 요소에 접근 가능
  3. 자식클래스 참조변수=new 부모클래스();//불가능(에러)
     >> 자식인스턴스가 존재하지 않아 참조변수에 저장할 경우 에러 발생
  4. 부모클래스 참조변수=new 자식클래스();
     >> 참조변수는 기본적으로 부모클래스의 요소에 접근 가능
     >> 객체 형변환을 이용하면 자식클래스의 요소에 접근 가능
  - 객체 형변환 : 상속관계의 클래스에서 구현
    1) 명시적 형변환(강제형변환) >> cast 연산자 이용
       (자식클래스명)참조변수  >> 참조변수의 자료형을 상속관계의 자식클래스로 잠시 변환 
    2) 묵시적 형변환(자동형변환) >> 메소드 오버라이딩을 이용
  - 메소드 오버라이드에 의한 다형성
    >> 부모참조변수에 저장된 자식인스턴스에 따라 자식인스턴스의 메소드 호출
    >> 부모참조변수에 저장된 자식인스턴스를 JVM이 자동으로 구분하여 처리
  - instanceof 연산자
    >> 부모참조변수로 객체 형변환 가능한 자식인스턴스을 구분하기 위한 연산자
    형식) 참조변수 instanceof 자식클래스
    >> 참조변수가 자식클래스로 객체 형변환 가능한 경우 true 제공

● final 키워드
  1. final 필드
   형식) 접근지정자 final 자료형 필드명=값;
   - 필드값 변경 불가능
   ※ final 필드명은 모두 대문자로 작성하며 단어 구분자로 _ 사용
   ※ 상수필드(Constant Field) : 상수 대신 사용하기 위한 고유명칭 
      형식) public static final 필드명=값;
   ex) java.lang.Math 클래스 - public static final double PI
       >> API 문서에서 Constant Field Values 에서 저장된 값 확인

  2. final 메소드
   형식) 접근지정자 final 반환형 메소드명(파라메터,...) {
		명령;
		...
         }          
   - 메소드 오버라이드 선언 불가능
   ex) java.lang.Object 클래스 - public final void notify() 메소드

  3. final 클래스
   형식) 접근지정자 final class 클래스명 { }
   - 상속 불가능 >> 부모클래스로 사용 불가능
   ex) java.lang.System 클래스 - public final class System extends Object 

● 추상클래스(Abstract Class)
  - 추상클래스 선언
    형식) 접근지정자 abstract class 클래스명 { }
  - 추상클래스는 인스턴스 생성 불가능 >> 상속 목적의 클래스
  - 추상메소드를 1개라도 가지고 있으면 반드시 추상클래스 선언
  - 추상메소드 >> 영역이 없는 불완전한 메소드 : 명령 미존재
    형식) 접근지정자 abstract 반환명 메소드명(파라메터,...);
  - 추상메소드가 존재하는 추상클래스를 상속받은 자식클래스는 모든 추상메소드를 반드시 오버라이드 선언
    >> 추상메소드를 오버라이드 선언하지 않을 경우 자식클래스도 추상클래스로 작성
  - 추상메소드를 만들어 주는 이유
    >> 자식클래스에서 반드시 선언해야 되는 메소드와 작성규칙 제공 : 작업명세서
  - 추상클래스(부모)로 참조변수를 만들어 자식인스턴스의 정보 저장 >> 객체 형변환 이용